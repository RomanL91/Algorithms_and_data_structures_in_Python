# Так я уже приобрел минимально понимание что такое ориентированный и 
# неориентированный граф, а так же что значит взвешанный он или нет.
# Если вспомнить, то там было еще что граф может быть мультиграфом.
# Что это? И как реализовать попробую разхобрать сейчас.
# Граф становится мультиграфом, когда между вершинами графа есть более
# одного типа связи. О чем это я? Если попробовать привести пример, то
# придумаем следующию ситацию (пример может быть не очень, но все же..):
# есть вершина (ЗАВОД) и еще 2 вершины (ПРЕДПРИЯТИЯ). Завод производит продукцию
# и продает ее (это первый тип связи) предприятиям. Предприятия
# изготавливают товар и продают заводу - относительно вершины ЗАВОД - 
# это покупка от предприятий (это второй тип связи)
#          _______         _______         _______
#         |      |---п--->|      |---з--->|      |
#         |   п  |        |   з  |        |   п  |
#         |______|<--з----|______|<---п---|______|
# 
# Думаю так можно представить 
#    |-->> взвешанный (у ребер есть вес - цена продажи продукта)
#    |-->> ориентированный (есть покупки, есть продажи - это направление транзакции)
#    |-->> мульти- (между двумя вершинами больше одного типа связи)
#    |-->> граф.
# 
# Как же хранить такие данные?
# Первое, что приходит в голову - это хранение уже 2 матриц смежности.
# В одной будем значения продаж, в другой покупки относительно вершины.
# А метод connect с прошлого примера, теперь будет назван sell.
# По логике, если одна вершина продала другой, то мы дожны внести 
# изменения в 2 таблица.
# 
# Попробую реализовать.
# 


from typing import List


class Node:
    def __init__(self, name_node: str, index_node = None) -> None:
        self.name_node = name_node
        self.index_node = index_node


    def __repr__(self) -> str:
        return self.name_node


class Graph:
    def __init__(self, row, col, nodes = None) -> None:
        self.graph = [[0] * col for _ in range(row)]
        self.nodes = nodes
        for i in range(len(self.nodes)):
            self.nodes[i].index_node = i


    @classmethod
    def create_from_nodes(self, nodes: List[Node]):
        return Graph(len(nodes), len(nodes), nodes)


    def sell(self, sell_from: Node, sell_to: Node, price_contract: int) -> List[List[int]]:
        self.graph[sell_from.index_node][sell_to.index_node] = price_contract



    def show_graph(self):
        print('Таблица продаж (строка)/покупок (столбец):')
        for i in self.graph:
            print(i)


if __name__ == '__main__':
    Factory = Node('Завод')

    Enterprise_1 = Node('Предприятие_1')
    Enterprise_2 = Node('Предприятие_2')

    graph = Graph.create_from_nodes([Factory, Enterprise_1, Enterprise_2])

    graph.sell(Factory, Enterprise_1, 7)
    graph.sell(Factory, Enterprise_2, 5)

    graph.sell(Enterprise_1, Factory, 4)

    graph.sell(Enterprise_2, Enterprise_1, 2)

    graph.show_graph()

# Вывод:
#            п  п  п
#            о  о  о
#            к  к  к
#            у  у  у
#            п  п  п
#            к  к  к
#            а  а  а
#           [0, 7, 5] - продажи узла Завод
#           [4, 0, 0] - продажи узла Предприятие_1
#           [0, 2, 0] - продажи узла Предприятие_2
#           
# В данном примере получилось обойтись одной таблицой, так как 
# типов связей две. Если бы их было больше, то может пришлось выделить больше памяти
# и под каждый тип связи держать отдельную таблицу, как я предпологал вначале.
# Как я думаю, я правильно понял суть и смог представить взвешанный ориентированный
# мультиграф. Как читать такую таблицу (оставлю пояснения самому себе из будущего)?
# Все просто, на сколько я могу предпологать так дела обстоят почти во всех
# ориентированных графах. По строке мы будем видеть продажи узла - кому и сколько, 
# а по стобцу будем видет покупки узла - от кого и сколько. Оценим продажи и покупки 
# Предприятие_1: Предприятие_1 имеет индекс = 1, смотрим строку под индексом 1 -
# [4, 0, 0]. Не нулевое значение в данной строке находится под индексом 0 - этот индекс 
# соотвествует Заводу, само же значение ровно 4 - что значит, что Предприятие_1 продало
# Заводу с ценой 4 (или 4 раза). По аналогии с покупками, только смотрим столбец - и тут
# Предприятие_1 купило у завода и Предприятие_2.
